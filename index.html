<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LO-FI ANGELS: REBIRTH</title>
  <link rel="icon" href="data:,">
  <style>
    :root{
      --bg:#020202;
      --panel:#111116;
      --text:#a0a0b0;
      --accent:#7d3cff;
      --danger:#ff2a2a;
      --light:#e0e0e0;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:'Courier New', monospace; overflow:hidden;}
    #wrap{position:fixed; inset:0;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block; image-rendering:pixelated; background:#050505;}
    
    /* CRT Scanline Overlay */
    #crt{
      position:absolute; inset:0; pointer-events:none; z-index:10;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      background-size: 100% 2px, 3px 100%;
      box-shadow: inset 0 0 80px rgba(0,0,0,0.7);
    }

    .overlay{
      position:absolute; inset:0; display:grid; place-items:center; z-index:20;
      background: rgba(0,0,0,0.85);
      transition: opacity 0.3s;
    }
    .panel{
      width:min(800px, 90vw);
      background:var(--panel); border:1px solid #333; box-shadow: 0 0 20px #000;
      padding:24px; position:relative;
    }
    .panel::before{
      content:""; position:absolute; top:-1px; left:10px; right:10px; height:1px; background:var(--accent); box-shadow:0 0 10px var(--accent);
    }
    
    h1{ margin:0 0 10px 0; font-size:24px; color:var(--light); text-transform:uppercase; letter-spacing:4px; text-shadow:0 0 8px var(--accent); }
    h1 span{ font-size:12px; color:#666; vertical-align:middle; letter-spacing:1px; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:20px; margin-top:20px; }
    input[type="text"]{
      width:100%; box-sizing:border-box; background:#000; border:1px solid #444; color:white; padding:12px; font-family:inherit; outline:none;
    }
    input[type="text"]:focus{ border-color:var(--accent); }

    .btn{
      background:#000; color:var(--light); border:1px solid #444; padding:10px 20px; 
      font-family:inherit; font-weight:bold; cursor:pointer; text-transform:uppercase;
      transition:0.2s;
    }
    .btn:hover{ background:var(--accent); color:#fff; border-color:var(--accent); box-shadow:0 0 15px var(--accent); }
    .btn.secondary{ border-color:#333; color:#666; }
    .btn.secondary:hover{ border-color:#666; background:#222; color:#fff; box-shadow:none; }

    .help{ margin-top:15px; font-size:12px; color:#666; line-height:1.5; }
    .kbd{ border:1px solid #444; padding:2px 6px; border-radius:4px; color:#fff; background:#222; }

    .mono{
      white-space:pre-wrap; font-size:14px; line-height:1.6; color:#ccc; 
      border-left:2px solid var(--accent); padding-left:15px; margin-top:10px;
    }

    /* Avatars */
    .avatars{ display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin-top:5px; }
    .avi{ 
      border:1px solid #333; padding:10px; cursor:pointer; opacity:0.6; transition:0.2s;
      display:flex; flex-direction:column; gap:4px;
    }
    .avi:hover{ opacity:1; border-color:#666; }
    .avi.sel{ opacity:1; border-color:var(--accent); background:#1a1025; }
    .avi b{ color:#fff; font-size:14px; }
    .avi small{ font-size:11px; color:#888; }

    #ui_layer{ pointer-events:none; position:absolute; top:20px; left:20px; right:20px; display:flex; justify-content:space-between; z-index:15; mix-blend-mode:difference; }
    .bar{ height:4px; width:100px; background:#333; margin-bottom:5px; position:relative; }
    .fill{ height:100%; background:#fff; width:100%; transition:width 0.2s; }
    .stat{ font-size:10px; color:#fff; font-weight:bold; text-transform:uppercase; letter-spacing:1px; }

  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div id="crt"></div> <div id="ui_layer" style="display:none">
      <div>
        <div class="stat">Integrity</div>
        <div class="bar"><div id="ui_hp" class="fill" style="background:var(--danger)"></div></div>
        <div class="stat">Light / Sanity</div>
        <div class="bar"><div id="ui_san" class="fill" style="background:var(--accent)"></div></div>
      </div>
      <div style="text-align:right">
        <div class="stat" id="ui_score">DEPTH: 0m</div>
        <div class="stat" style="color:#666" id="ui_tension">ATMOSPHERE</div>
      </div>
    </div>

    <div id="menuOverlay" class="overlay">
      <div class="panel">
        <h1>Lo-Fi Angels <span>// REBIRTH_PROTOCOL</span></h1>
        <div class="help">
          An atmospheric horror run & gun. <br/>
          The fog is thick. Your <b>Sanity</b> fuels your light. <br/>
          <br/>
          <span style="color:var(--danger)">WARNING:</span> Avoid the spectral shapes. Do not kill the <b>Daughter</b> (Green Ghost).
        </div>

        <div class="grid">
          <div>
            <label style="font-size:12px; color:#666;">IDENTITY</label>
            <input id="playerName" type="text" placeholder="ENTER NAME" value="SEEKER" maxlength="12" style="margin-top:5px;">
            <div class="help">
              <span class="kbd">WASD</span> Move/Jump<br/>
              <span class="kbd">MOUSE</span> Aim<br/>
              <span class="kbd">CLICK</span> Fire<br/>
              <span class="kbd">E</span> Interact
            </div>
          </div>
          <div>
            <label style="font-size:12px; color:#666;">CLASS</label>
            <div class="avatars">
              <div class="avi sel" onclick="selectAvi(0, this)"><b>Vanguard</b><small>Balanced</small></div>
              <div class="avi" onclick="selectAvi(1, this)"><b>Occultist</b><small>High Sanity</small></div>
              <div class="avi" onclick="selectAvi(2, this)"><b>Heavy</b><small>High HP</small></div>
            </div>
            <button id="startBtn" class="btn" style="width:100%; margin-top:20px;">INITIATE</button>
          </div>
        </div>
      </div>
    </div>

    <div id="loreOverlay" class="overlay" style="display:none">
      <div class="panel">
        <h1 style="font-size:18px; color:var(--accent)">ARCHIVE DATA</h1>
        <div id="loreText" class="mono"></div>
        <div style="margin-top:20px; text-align:right">
          <button id="closeLoreBtn" class="btn secondary">CLOSE [SPACE]</button>
        </div>
      </div>
    </div>

    <div id="overOverlay" class="overlay" style="display:none">
      <div class="panel" style="text-align:center">
        <h1 id="overTitle" style="color:var(--danger)">SIGNAL LOST</h1>
        <div id="overReason" class="mono" style="text-align:center; border:none;"></div>
        <div style="margin-top:30px;">
          <button onclick="location.reload()" class="btn">REBOOT SYSTEM</button>
        </div>
      </div>
    </div>

  </div>

<script>
// --- ENGINE SETUP ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
let width, height;
const resize = () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
};
window.addEventListener('resize', resize);
resize();

// --- CONFIG ---
const GRAVITY = 700; 
const GROUND_Y = () => height - 100;
const PAL = {
  bg: '#050505',
  ground: '#0a0a0d',
  obs: '#15151a',
  player: '#e0e0e0',
  playerDim: '#666',
  enemy: '#ff2a2a',
  daughter: '#00ffaa', // Distinct Green
  daughterGlow: 'rgba(0,255,170,0.2)',
  light: 'rgba(255, 240, 200, 0.08)',
  tree: '#0d0d10'
};

// --- UTILS ---
const rand = (min, max) => Math.random() * (max - min) + min;
const randi = (min, max) => Math.floor(rand(min, max));
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
const aabb = (r1, r2) => r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;

// --- AUDIO SYSTEM (Procedural) ---
const Audio = {
  ctx: null,
  master: null,
  start: function() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.3;
    this.master.connect(this.ctx.destination);
    this.drone();
  },
  drone: function() {
    // Spooky background drone
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.frequency.value = 55; // Low A
    osc.type = 'sawtooth';
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 120;
    
    // LFO for drone wobble
    const lfo = this.ctx.createOscillator();
    lfo.frequency.value = 0.1;
    const lfoG = this.ctx.createGain();
    lfoG.gain.value = 50;
    lfo.connect(lfoG);
    lfoG.connect(filter.frequency);
    lfo.start();

    osc.connect(filter).connect(g).connect(this.master);
    g.gain.value = 0.5;
    osc.start();
  },
  play: function(type) {
    if(!this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.connect(g).connect(this.master);
    
    if (type === 'shoot') {
      osc.type = 'square';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
      g.gain.setValueAtTime(0.2, t);
      g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
    } else if (type === 'jump') {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.linearRampToValueAtTime(100, t + 0.2);
      g.gain.setValueAtTime(0.2, t);
      g.gain.linearRampToValueAtTime(0.01, t + 0.2);
      osc.start(t); osc.stop(t + 0.2);
    } else if (type === 'hit') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(100, t);
      osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
      g.gain.setValueAtTime(0.3, t);
      g.gain.linearRampToValueAtTime(0.01, t + 0.3);
      osc.start(t); osc.stop(t + 0.3);
    }
  }
};

// --- GAME CLASSES ---

class Particle {
  constructor(x, y, color, speed) {
    this.x = x; this.y = y; this.color = color;
    this.vx = rand(-speed, speed);
    this.vy = rand(-speed, speed);
    this.life = 1.0;
    this.decay = rand(0.02, 0.05);
  }
  update() {
    this.x += this.vx; this.y += this.vy;
    this.life -= this.decay;
  }
  draw(ctx, camX) {
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x - camX, this.y, 2, 2);
    ctx.globalAlpha = 1;
  }
}

class Entity {
  constructor(x, y, w, h) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.vx = 0; this.vy = 0;
    this.grounded = false;
    this.dead = false;
  }
  update(dt, world) {
    this.vy += GRAVITY * dt;
    this.x += this.vx * dt;
    this.y += this.vy * dt;

    // Ground Collision
    this.grounded = false;
    if (this.y + this.h >= GROUND_Y()) {
      this.y = GROUND_Y() - this.h;
      this.vy = 0;
      this.grounded = true;
    }

    // Object Collision
    world.obstacles.forEach(o => {
      if (aabb(this, o)) {
        // Simple resolution: if we were above it, land on it. 
        // If we hit side, stop.
        const prevY = this.y - this.vy * dt;
        if (prevY + this.h <= o.y) {
          this.y = o.y - this.h;
          this.vy = 0;
          this.grounded = true;
        } else {
          // Hit side
          this.x -= this.vx * dt;
          this.vx = 0;
        }
      }
    });
  }
}

class Player extends Entity {
  constructor() {
    super(200, 0, 16, 32);
    this.speed = 180;
    this.hp = 100;
    this.sanity = 100;
    this.maxHp = 100;
    this.lantern = 150; // Radius
    this.facing = 1;
    this.cooldown = 0;
  }
  update(dt, input, world) {
    // Horizontal
    let dir = 0;
    if (input.keys['KeyA']) dir = -1;
    if (input.keys['KeyD']) dir = 1;
    this.vx = dir * this.speed;
    if (dir !== 0) this.facing = dir;

    // Jump
    if (input.keys['KeyW'] && this.grounded) {
      this.vy = -450; // Increased jump power
      Audio.play('jump');
      this.grounded = false;
    }

    super.update(dt, world);

    // Shooting
    if (this.cooldown > 0) this.cooldown -= dt;
    if (input.mouse.down && this.cooldown <= 0) {
      this.cooldown = 0.15;
      Audio.play('shoot');
      const mx = input.mouse.x + world.camX;
      const my = input.mouse.y;
      const angle = Math.atan2(my - (this.y + 10), mx - (this.x + 8));
      world.bullets.push(new Bullet(this.x + 8, this.y + 10, angle));
      // Shooting costs a tiny bit of sanity
      this.sanity = Math.max(0, this.sanity - 0.5);
    }

    // Sanity Decay -> Lantern Dimming
    this.sanity = Math.max(0, this.sanity - dt * 0.8);
    // Lantern radius linked to sanity
    this.lantern = 50 + (this.sanity / 100) * 200;
    
    // Bounds
    if (this.x < world.camX) this.x = world.camX;
  }

  draw(ctx, camX) {
    // Body (Not just a box anymore - layers)
    let x = this.x - camX;
    
    // Scarf/Cape trail
    ctx.fillStyle = '#ff3366';
    ctx.fillRect(x + (this.facing === 1 ? -4 : 12), this.y + 8, 8, 4);

    // Main Body
    ctx.fillStyle = PAL.player;
    ctx.fillRect(x, this.y, this.w, this.h);
    
    // Head/Goggles
    ctx.fillStyle = '#222';
    ctx.fillRect(x + 2, this.y + 2, 12, 8);
    ctx.fillStyle = '#0ff'; // Glowing eye
    ctx.fillRect(x + (this.facing === 1 ? 8 : 4), this.y + 4, 3, 2);

    // Gun
    ctx.fillStyle = '#555';
    ctx.fillRect(x + (this.facing === 1 ? 10 : -6), this.y + 14, 12, 4);
  }
}

class Daughter extends Entity {
  constructor(x) {
    super(x, 0, 14, 24);
    this.timer = 0;
    this.state = 'wander'; // wander, cower
    this.cowerTime = 0;
  }
  update(dt, world) {
    const p = world.player;
    const distToPlayer = Math.abs(p.x - this.x);
    
    // AI Logic
    if (this.state === 'cower') {
      this.vx = 0;
      this.h = 16; // Crouch
      this.cowerTime -= dt;
      if (this.cowerTime <= 0) {
        this.state = 'wander';
        this.h = 24;
      }
    } else {
      // Wander logic
      this.timer -= dt;
      if (this.timer <= 0) {
        this.vx = rand(-40, 40);
        this.timer = rand(1, 3);
      }
      
      // Run away from enemies slightly
      let nearestEnemy = null;
      let minDst = 150;
      world.enemies.forEach(e => {
        const d = Math.abs(e.x - this.x);
        if(d < minDst) { minDst = d; nearestEnemy = e; }
      });
      
      if (nearestEnemy) {
        this.vx = (this.x < nearestEnemy.x ? -1 : 1) * 60;
      }
      
      // If bullets are flying near, COWER
      world.bullets.forEach(b => {
        if (dist(b, this) < 80) {
          this.state = 'cower';
          this.cowerTime = 1.5;
        }
      });
    }

    super.update(dt, world);
  }
  draw(ctx, camX) {
    const x = this.x - camX;
    
    // Glow
    ctx.fillStyle = PAL.daughterGlow;
    ctx.beginPath(); arc(ctx, x + 7, this.y + 12, 20); ctx.fill();

    // Body (Ghostly)
    ctx.fillStyle = PAL.daughter;
    // Draw dress shape
    ctx.beginPath();
    ctx.moveTo(x + 7, this.y);
    ctx.lineTo(x + 14, this.y + this.h);
    ctx.lineTo(x, this.y + this.h);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#005522';
    ctx.fillRect(x + 4, this.y + 6, 2, 2);
    ctx.fillRect(x + 9, this.y + 6, 2, 2);

    if (this.state === 'cower') {
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.fillText("!", x+5, this.y - 5);
    }
  }
}

class Enemy extends Entity {
  constructor(x, y, type) {
    super(x, y, 20, 30);
    this.type = type; // 'walker' or 'flyer'
    this.hp = 30;
    if (type === 'flyer') {
      this.w = 16; this.h = 16; this.hp = 15;
    }
  }
  update(dt, world) {
    const p = world.player;
    const dx = p.x - this.x;
    const dy = p.y - this.y;
    
    if (this.type === 'walker') {
      this.vx = (dx > 0 ? 1 : -1) * (rand(40, 70));
      super.update(dt, world);
      // Jump over obstacles
      if (this.vx === 0 && this.grounded) this.vy = -350;
    } else {
      // Flyer - Sine wave movement towards player
      this.x += (dx > 0 ? 1 : -1) * 90 * dt;
      this.y += (dy > 0 ? 1 : -1) * 30 * dt + Math.sin(Date.now()/200)*2;
    }

    // Hit Player
    if (aabb(this, p)) {
      p.hp -= 0.5;
      p.sanity -= 0.2;
      world.particles.push(new Particle(p.x, p.y, '#f00', 5));
    }
  }
  draw(ctx, camX) {
    const x = this.x - camX;
    ctx.fillStyle = PAL.enemy;
    
    if (this.type === 'walker') {
      // Glitchy shape
      ctx.fillRect(x, this.y, this.w, this.h);
      // Spikes
      ctx.beginPath();
      ctx.moveTo(x, this.y); ctx.lineTo(x-5, this.y-5); ctx.lineTo(x+5, this.y);
      ctx.stroke();
    } else {
      // Flyer shape (Triangle)
      ctx.beginPath();
      ctx.moveTo(x, this.y); 
      ctx.lineTo(x+this.w, this.y); 
      ctx.lineTo(x+this.w/2, this.y+this.h);
      ctx.fill();
      // Wings
      ctx.fillStyle = 'rgba(255,50,50,0.5)';
      const flap = Math.sin(Date.now()/50) * 10;
      ctx.fillRect(x - 10, this.y, 10, 5 + flap);
      ctx.fillRect(x + this.w, this.y, 10, 5 + flap);
    }
  }
}

class Bullet {
  constructor(x, y, ang) {
    this.x = x; this.y = y; this.vx = Math.cos(ang)*600; this.vy = Math.sin(ang)*600;
    this.dead = false; this.w=4; this.h=4;
  }
  update(dt, world) {
    this.x += this.vx * dt; this.y += this.vy * dt;
    if (this.y > height || this.x > world.player.x + width) this.dead = true;
    
    // Hit Enemy
    world.enemies.forEach(e => {
      if (aabb(this, e)) {
        this.dead = true;
        e.hp -= 10;
        Audio.play('hit');
        if (e.hp <= 0) {
          e.dead = true;
          // Spawn HP or Sanity
          if (Math.random() > 0.7) world.pickups.push({x:e.x, y:e.y, type: Math.random()>0.5?'hp':'san'});
        }
        world.addParticles(this.x, this.y, '#fff', 5);
      }
    });

    // Hit Daughter (BAD)
    world.daughters.forEach(d => {
      if(aabb(this, d)) {
        gameOver('YOU KILLED THE CHILD.\nTHE CYCLE IS BROKEN.\nHOPE IS GONE.');
      }
    });
    
    // Hit Obstacle
    world.obstacles.forEach(o => {
      if (aabb(this, o)) { this.dead = true; world.addParticles(this.x, this.y, '#888', 3); }
    });
  }
  draw(ctx, camX) {
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(this.x - camX, this.y, 4, 4);
  }
}

class Decoration {
  constructor(x, type) {
    this.x = x;
    this.type = type; // tree, grave, house
    this.scale = rand(0.8, 1.2);
  }
  draw(ctx, camX) {
    const x = this.x - camX;
    if (x < -200 || x > width + 200) return;
    
    ctx.fillStyle = '#0f0f14';
    const y = GROUND_Y();
    
    if (this.type === 'tree') {
      // Draw Dead Tree using lines
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 5*this.scale, y - 100*this.scale);
      ctx.lineTo(x - 20*this.scale, y - 140*this.scale); // branch left
      ctx.moveTo(x + 5*this.scale, y - 100*this.scale);
      ctx.lineTo(x + 30*this.scale, y - 150*this.scale); // branch right
      ctx.lineWidth = 4 * this.scale;
      ctx.strokeStyle = '#111';
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (this.type === 'house') {
      // Abandoned House
      ctx.fillStyle = '#08080a';
      ctx.fillRect(x, y - 80*this.scale, 80*this.scale, 80*this.scale);
      // Roof
      ctx.beginPath();
      ctx.moveTo(x - 10, y - 80*this.scale);
      ctx.lineTo(x + 40*this.scale, y - 130*this.scale);
      ctx.lineTo(x + 90*this.scale, y - 80*this.scale);
      ctx.fill();
      // Windows (dark)
      ctx.fillStyle = '#000';
      ctx.fillRect(x + 10, y - 50*this.scale, 20, 30);
    } else {
      // Grave
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(x, y - 20, 15, Math.PI, 0);
      ctx.lineTo(x+15, y);
      ctx.lineTo(x-15, y);
      ctx.fill();
    }
  }
}

// --- WORLD MANAGER ---

class World {
  constructor() {
    this.reset();
  }
  reset() {
    this.camX = 0;
    this.player = new Player();
    this.bullets = [];
    this.enemies = [];
    this.particles = [];
    this.obstacles = [];
    this.pickups = [];
    this.daughters = [];
    this.decorations = [];
    this.score = 0;
    this.tension = 0; // 0 to 1
    
    // Generate Level Chunks
    this.genLevel();
  }

  genLevel() {
    let x = 400;
    // Floor
    for(let i=0; i<200; i++) {
      // Obstacles (Capped height for jumpability)
      if (Math.random() > 0.7) {
        const h = randi(20, 50); // Player jump is ~100+
        const w = randi(30, 80);
        this.obstacles.push({x, y: GROUND_Y() - h, w, h});
      }
      
      // Decorations
      if (Math.random() > 0.8) {
        const types = ['tree', 'tree', 'grave', 'house'];
        this.decorations.push(new Decoration(x + rand(-50,50), types[randi(0,4)]));
      }

      // Enemy triggers (Spawn later)
      
      // Daughter spawns every 2000px roughly
      if (i > 0 && i % 15 === 0) {
        this.daughters.push(new Daughter(x));
      }
      
      x += rand(100, 300);
    }
  }

  addParticles(x, y, c, n) {
    for(let i=0; i<n; i++) this.particles.push(new Particle(x,y,c, 10));
  }

  update(dt, input) {
    this.player.update(dt, input, this);
    
    // Camera
    this.camX = this.player.x - width * 0.3;
    if (this.camX < 0) this.camX = 0;

    // Entities
    [...this.bullets, ...this.enemies, ...this.daughters, ...this.particles].forEach(e => e.update(dt, this));
    
    // Cleanup
    this.bullets = this.bullets.filter(b => !b.dead);
    this.enemies = this.enemies.filter(e => !e.dead);
    this.particles = this.particles.filter(p => p.life > 0);
    
    // Pickups
    this.pickups.forEach((p, i) => {
      // Simple collision
      const py = p.y - 10 + Math.sin(Date.now()/200)*5;
      if (dist({x:p.x, y:py}, this.player) < 30) {
        if(p.type==='hp') this.player.hp = Math.min(100, this.player.hp+25);
        if(p.type==='san') this.player.sanity = Math.min(100, this.player.sanity+30);
        this.pickups.splice(i, 1);
        Audio.play('jump'); // reuse sound
      }
    });

    // Spawning Logic (Tension Manager)
    this.score = Math.floor(this.player.x / 10);
    // More tension deeper in
    const tensionTarget = Math.min(1, this.score / 500); 
    if (Math.random() < 0.01 + (tensionTarget * 0.03)) {
      // Spawn enemy ahead
      const type = Math.random() > 0.7 ? 'flyer' : 'walker';
      this.enemies.push(new Enemy(this.player.x + width + 50, GROUND_Y() - 50, type));
    }

    // Game Over Checks
    if (this.player.hp <= 0) gameOver('PHYSICAL VESSEL DESTROYED');
    if (this.player.sanity <= 0) gameOver('MIND FRACTURED. LOST TO THE DARKNESS.');
  }

  draw() {
    // 1. Clear & Sky
    ctx.fillStyle = PAL.bg;
    ctx.fillRect(0, 0, width, height);

    // 2. Parallax / Decorations
    this.decorations.forEach(d => d.draw(ctx, this.camX * 0.5)); // Far bg move slower
    
    // 3. Ground
    ctx.fillStyle = PAL.ground;
    ctx.fillRect(0, GROUND_Y(), width, height - GROUND_Y());
    
    // 4. World Objects
    ctx.fillStyle = PAL.obs;
    this.obstacles.forEach(o => {
      if (o.x - this.camX < width && o.x + o.w - this.camX > 0)
        ctx.fillRect(o.x - this.camX, o.y, o.w, o.h);
    });

    // 5. Entities
    this.pickups.forEach(p => {
      const y = p.y - 10 + Math.sin(Date.now()/200)*5;
      ctx.fillStyle = p.type === 'hp' ? '#f00' : '#a0f';
      ctx.fillRect(p.x - this.camX, y, 10, 10);
      ctx.font = '10px monospace'; ctx.fillStyle='#fff';
      ctx.fillText(p.type.toUpperCase(), p.x - this.camX, y-5);
    });

    this.daughters.forEach(d => d.draw(ctx, this.camX));
    this.enemies.forEach(e => e.draw(ctx, this.camX));
    this.player.draw(ctx, this.camX);
    this.bullets.forEach(b => b.draw(ctx, this.camX));
    this.particles.forEach(p => p.draw(ctx, this.camX));

    // 6. LIGHTING & ATMOSPHERE SYSTEM
    // Create a dark mask
    ctx.globalCompositeOperation = 'multiply';
    
    // The "Darkness"
    // We create a radial gradient around the player
    const px = this.player.x - this.camX + 8;
    const py = this.player.y + 16;
    const rad = this.player.lantern;
    
    const grad = ctx.createRadialGradient(px, py, rad * 0.2, px, py, rad);
    grad.addColorStop(0, 'white'); // Fully lit (multiply by white = no change)
    grad.addColorStop(1, 'black'); // Pitch black (multiply by black = black)
    
    ctx.fillStyle = grad;
    // Fill the whole screen with the darkness gradient
    // BUT we need to fill the rest with black first?
    // Actually, 'multiply' means white preserves, black darkens.
    
    // Fill screen with black first? No.
    // We want to darken everything EXCEPT the player.
    
    // Let's use source-over with a radial gradient that is transparent in center and black outside.
    ctx.globalCompositeOperation = 'source-over';
    const fog = ctx.createRadialGradient(px, py, rad * 0.2, px, py, rad * 1.5);
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(0.5, 'rgba(0,0,0,0.4)');
    fog.addColorStop(1, 'rgba(0,0,0,0.98)');
    
    ctx.fillStyle = fog;
    ctx.fillRect(0, 0, width, height);

    // Add Mist
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = '#111';
    for(let i=0; i<10; i++) {
        let mx = (Date.now()/50 + i*200) % (width + 400) - 200;
        ctx.fillRect(mx, 0, 100, height);
    }
    ctx.globalCompositeOperation = 'source-over';
  }
}

// --- MAIN LOOP & STATE ---
const world = new World();
let lastTime = 0;
let gameState = 'menu'; // menu, playing, over

// Input Handler
const Input = {
  keys: {},
  mouse: {x:0, y:0, down:false}
};
window.addEventListener('keydown', e => Input.keys[e.code] = true);
window.addEventListener('keyup', e => Input.keys[e.code] = false);
window.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  Input.mouse.x = e.clientX - r.left;
  Input.mouse.y = e.clientY - r.top;
});
window.addEventListener('mousedown', () => Input.mouse.down = true);
window.addEventListener('mouseup', () => Input.mouse.down = false);

// Arc helper
function arc(ctx, x, y, r) { ctx.arc(x,y,r,0,Math.PI*2); }

function loop(t) {
  const dt = Math.min((t - lastTime) / 1000, 0.1);
  lastTime = t;

  if (gameState === 'playing') {
    world.update(dt, Input);
    world.draw();
    
    // UI Update
    document.getElementById('ui_hp').style.width = world.player.hp + '%';
    document.getElementById('ui_san').style.width = world.player.sanity + '%';
    document.getElementById('ui_score').innerText = 'DEPTH: ' + world.score + 'm';
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// --- UI LOGIC ---
let selectedAvatar = 0;
window.selectAvi = (id, el) => {
  document.querySelectorAll('.avi').forEach(d => d.classList.remove('sel'));
  el.classList.add('sel');
  selectedAvatar = id;
};

document.getElementById('startBtn').onclick = () => {
  document.getElementById('menuOverlay').style.display = 'none';
  document.getElementById('ui_layer').style.display = 'flex';
  Audio.start();
  gameState = 'playing';
  world.reset();
  
  // Apply class stats
  if(selectedAvatar === 1) { world.player.sanity = 150; world.player.lantern = 250; } // Occultist
  if(selectedAvatar === 2) { world.player.hp = 200; world.player.maxHp = 200; } // Heavy
};

function gameOver(reason) {
  gameState = 'over';
  document.getElementById('overOverlay').style.display = 'grid';
  document.getElementById('overReason').innerText = reason;
  document.getElementById('ui_layer').style.display = 'none';
}

// Lore Trigger (Simple random event logic)
setInterval(() => {
  if (gameState !== 'playing') return;
  if (Math.random() < 0.05 && world.player.sanity > 20) {
    // Glitch text effect in console
    console.log("THEY ARE WATCHING " + Date.now());
  }
}, 5000);

</script>
</body>
</html>

